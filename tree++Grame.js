/*---------------------------------------------------------------------------
运行示例：
someFunction(
‘x’,
[ 
  [‘o’, ‘e’, ‘e’],

  [‘o’, ‘x’, ‘o’],

  [‘x’, ‘x’, ‘e’] 
]
)
// return [ [2, 2], [0, 1], [0, 2] ]
// 胜利规则：3 x 3 的井字棋游戏三颗棋连成一条线就算胜利。
----------------------------------------------------------------------------*/

 
/* 
  算法一：由于三3 x 3 的井字棋的胜利路径能很简单的推算出来：即横三，数三，斜三，所以，可以采取遍历法。
具体过程：先提前把所有胜利的路径坐标给出，然后在用当前棋盘中棋子去匹配坐标，根据胜利路径坐标来返回结果。
*/

//传入参数为棋手与棋盘，棋手为x或o表示，棋盘已一个二维数组表示

let netSuccess=(player,board)=>{  //声明一个三维数组来存储所有可能的胜利结果：共8种，
 
 successWays=[  
 [[0,0],[0,1],[0,2]],  //横三胜利路径坐标：3种
 [[1,0],[1,1],[1,2]],
 [[2,0],[2,1],[2,2]],
 [[0,0],[1,0],[2,0]],  //竖三胜利路径坐标: 3种
 [[0,1],[1,1],[2,1]],
 [[0,2],[1,2],[2,2]],
 [[0,0],[1,1],[2,2]],  //斜三胜利路径坐标: 3种
 [[2,0],[1,1],[0,2]],
 ]
 
 //声明一个结果数组
 let results=[];
 
 //一个循环得到所有的结果
 for(let i in successWays)
 {
   let res=0;//标志每条成功路径，已落的棋子数目，或1或2或3
   let empty=[]; //获取值每条胜利路径中的空缺点坐标
   for(let j in successWays[i])
    {
	   //获取每个点的坐标
	   let x=successWays[i][j][0];
	   let y=successWays[i][j][1];
	   //开始具体的判断
	   if(board[x][y]==player) res++;
	   else{
		   if(board[x][y]=='e')empty=[x,y];
	   }
    }
  //开始判断当前路径是否能够胜利
  if(res==2&&empty.length==2) results.push(empty);
 }
 //返回最后的结果
 return results;
}